Metatables! Truly an interesting subject. Through my activity in different forums and discord servers, I have seen many people get confused, on what they are. Main reason being, not a super wide collection of resources exist explaining it, and in general the idea of metatables is different and unique for someone who got used to simple notation, such as loops, and if statments.

**I**. Metatables
--
There isn't really a definition to what a metatable is. It's just that, any table can have a metatable. Stick with that idea. (and in addition, many tables can share the same metatable, a table can have multiple metatables, and a table can be its own metatable). At the end, a metatable is a table itself.

The idea behind metatables is, to make tables a more powerful object! To turn them, from simple data structures, with just a small collection of abilities:
* Storing pairs of keys and values
* Getting values back from keys
* The # operator

into something, with way more tools in the shed:
* All the normal abilities
* Do arithmetic on them (division, addition, subtraction..)
* Compare them
* Call them like functions
* `tostring()` them
* And much more!

![metatable1|641x500, 100%](upload://eemXC8NwUFFwSLhtw6MPHUz50yh.png) *(Image by @BenSBk)* 

To set a metatable `mt` to a table `t`, you need to use `setmetatable()`, and can use `getmetatable()` to get a table's metatable if you need it.
```
local t = {}
local mt = {}
setmetatable(t, mt)

print(getmetatable(t)) --returns mt, which is basically a table
```
An alternative, since `setmetatable()` returns the table we set the metatable of, we can do
```
local t = setmetatable({}, {})
--where the second table is the metatable, that we will fill with metamethods
```
II. Metamethods
--
Metamethods are the main source of a metatable's powers. They are keys we put inside of a metatable, which I'll show you how they work in a second. They are commonly prefixed with a `__` (like `__index`, `__newindex` ect.), and most commonly set to a function (and in some special cases, set to a table or a string, we will cover these cases).

We will start with the `__index` metamethod, which is one of the basic ones. `__index` can be set to a table, or a function. I'm gonna be covering the function first, because I think explaining the table part makes understanding other metamethods harder.
```
local t = setmetatable({}, {__index = function() end})
```




III. Operator Overloading
--

Operator overloading is making an operator (`+`, `-`, `*` ect. `==`, `>`, `<` ect.) compatible with more than just one datatype. Meaning, you could do `num + num`, what about doing `string  + string`? Of course here we are interested in tables. Yeah! We can actually add, subtract, multiply or do any sort of arithmetic on them. Here are the metamethods responsible for operator overloading.


![image|690x197, 75%](upload://rqXBrqq1A4Uzhxz96cIlbTBeEOY.png) 
![image|690x142, 75%](upload://lY0oMFNc4L5D7204WhmQfZCKHXJ.png) 

Of course we can put many different metamethods into one metatable, like this
```
local t = {}
local mt = {__add = function(v1, v2) end, __sub = function(v1, v2) end, 
__mul = function(v1, v2) end, __div = function(v1, v2) end}

setmetatable(t, mt)
```

Let's just start with one then fill the rest.
```
local t = {46, 35, 38}
local mt = {
     __add = function(v1, v2)
         return #v1 + v2 
     end
}
setmetatable(t, mt)

print(t + 5) --actually prints 8!
```
Pretty amazing right? We can now add table. 
As I said earlier, you can do whatever you want inside of the function, there isn't something exact. Adding tables doesn't really have a rule, it's weird. I came up with my own way of doing it,  by adding `#t` (`#v1`), how many elements are in `t`, with `5` (`v2`). You could've done something else, like looping through `t` (`v1`) and adding all of its elements (46, 35, 38) with `5` (`v2`).

 Note, if I did
```
print(5 + t) --this would error
```
Order matters. In the first script, `t` is `v1`, and `5` is `v2`. In the second script, `5` is `v1`, `t` is `v2`, which means I'm doing `#v1`, thus `#5`, which would error. So you need to make a bunch of if statments to watch out from cases like this.

Now what about adding tables? Same thing really. But both tables needs to have the `__add` metamethod. You can't add a table that has an `__add` with one that doesn't.
```
local t1 = {"hi", true}
local t2 = {79, "bye", false}
local mt = {__add = function(v1, v2) return #v1 + #v2 end}

setmetatable(t1, mt)
setmetatable(t2, mt) --both need to have __add, you can see they can share a metatable

print(t1 + t2) --prints 5
```
Two things to point out, order matters here as well, and also if you're wondering the metamethod will only invoke once and not twice. So yeah, you can do this with the other mathematical operations as well.

You can even concatenate (using the `..` operator on strings) on tables, using `__concat`.
```
local t1 = {"hi", true}
local t2 = {79, "bye", false}
local mt = {
    __concat = function(v1, v2)
        local output = {}
        for i, v in pairs(v1) do
            table.insert(output, v)
        end
        for i, v in pairs(v2) do
            table.insert(output, v)
        end
    end
}
setmetatable(t1, mt)
setmetatable(t2, mt) --they gotta have it both as well

local t3 = t1..t2 --we merged t1 and t2 together, as you can see you can get creative
print(unpack(t3)) --t3 contains all of t1 and t2's members
```
You also got `__lt` (less then), `__le` (less or equal to) and `__eq` (equal) which you can explore yourself. A `__mt` (more then) and `__me` (more or equal to) don't exist, but you can simply invert the usage of the already existing ones, instead of doing `a > b` do `b < a`.

You also got `__unm`, which is basically the inverter operator, like doing `-5`, inverse of `5`
you can do `-table`. For example you can invert all of the table's elements.
